module Corps () where

import Data.Vector
import Prelude hiding (replicate, length)

-- Nombre de bits du corps
size :: Int
size = 8

(&) = flip ($)

-- XOR
(|&) :: Bool -> Bool -> Bool
(|&) a b = (a || b) && not (a && b)




-- Type Polynome dans Z/2Z
-- Petit Endian
type Poly = Vector Bool

toDigits :: Poly -> String
toDigits v = foldl' accu "" v
            where accu s b = showDigit b : s
                  showDigit b = if b then '1' else '0'

makePoly :: Int -> Integer -> Poly
makePoly s n = generate s (getBinDigit n)
                where getBinDigit n i = (n `quot` (2 ^ i) `mod` 2) == 1

-- Realise y + x*X^k
-- on doit avoir (k + length x) <= length y
addPolyWithShift :: Int -> Poly -> Poly -> Poly
addPolyWithShift k x y = generate (length y) aux
        where aux i = if i >= k && i < k + length x
                  then (y ! i) |& (x ! (i-k))
                  else y ! i

multPoly :: Poly -> Poly -> Poly
multPoly x y = ifoldl add z0 x
    where z0 = replicate (2 * length x) False 
          add z i b = 
                if not b then z
                else addPolyWithShift i y z

modPoly :: Poly -> Poly -> Poly
modPoly = undefined




-- Type Scalaire
data Field = F {toPoly :: Poly} 
           deriving (Eq)

prime :: Poly
prime = undefined

-- Neutre pour +
zero :: Field
zero = F $ replicate size False

-- Neutre pour *
one :: Field
one = F $ generate size (\i -> if i == 0 then 1 else 0)

instance Show Field where
        show = toDigits . toPoly

instance Num Field where
        x + y = F $ addPolyWithShift 0 (toPoly x) (toPoly y)
        x * y = multPoly (toPoly x) (toPoly y)
                    & modPoly prime
                    & (force . slice 0 size)
                    & F
        abs = id
        signum x = one
        negate = id
        fromInteger = F . makePoly size
